"""
NetLink Vulnerability Scanner

Continuous vulnerability scanning with CVE database integration,
dependency scanning, and automated security assessments.
"""

import asyncio
import logging
import time
import json
import hashlib
import subprocess
from typing import Dict, List, Optional, Any, Set
from dataclasses import dataclass, field
from enum import Enum
from datetime import datetime, timezone, timedelta
import aiohttp
import aiofiles
from pathlib import Path

logger = logging.getLogger(__name__)


class VulnerabilityType(Enum):
    """Types of vulnerabilities."""
    CVE = "cve"
    DEPENDENCY = "dependency"
    CONFIGURATION = "configuration"
    NETWORK = "network"
    WEB_APPLICATION = "web_application"
    SYSTEM = "system"
    CRYPTOGRAPHIC = "cryptographic"
    ACCESS_CONTROL = "access_control"


class SeverityLevel(Enum):
    """CVSS severity levels."""
    NONE = 0.0
    LOW = 3.9
    MEDIUM = 6.9
    HIGH = 8.9
    CRITICAL = 10.0


class ScanStatus(Enum):
    """Scan status."""
    PENDING = "pending"
    RUNNING = "running"
    COMPLETED = "completed"
    FAILED = "failed"
    CANCELLED = "cancelled"


@dataclass
class Vulnerability:
    """Vulnerability information."""
    vuln_id: str
    cve_id: Optional[str]
    title: str
    description: str
    severity: SeverityLevel
    cvss_score: float
    vulnerability_type: VulnerabilityType
    affected_component: str
    affected_version: Optional[str]
    fixed_version: Optional[str]
    discovery_date: datetime
    published_date: Optional[datetime]
    references: List[str] = field(default_factory=list)
    exploit_available: bool = False
    patch_available: bool = False
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert vulnerability to dictionary."""
        return {
            "vuln_id": self.vuln_id,
            "cve_id": self.cve_id,
            "title": self.title,
            "description": self.description,
            "severity": self.severity.name,
            "cvss_score": self.cvss_score,
            "vulnerability_type": self.vulnerability_type.value,
            "affected_component": self.affected_component,
            "affected_version": self.affected_version,
            "fixed_version": self.fixed_version,
            "discovery_date": self.discovery_date.isoformat(),
            "published_date": self.published_date.isoformat() if self.published_date else None,
            "references": self.references,
            "exploit_available": self.exploit_available,
            "patch_available": self.patch_available
        }


@dataclass
class ScanResult:
    """Vulnerability scan result."""
    scan_id: str
    scan_type: str
    target: str
    status: ScanStatus
    start_time: datetime
    end_time: Optional[datetime]
    vulnerabilities: List[Vulnerability] = field(default_factory=list)
    scan_config: Dict[str, Any] = field(default_factory=dict)
    error_message: Optional[str] = None
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert scan result to dictionary."""
        return {
            "scan_id": self.scan_id,
            "scan_type": self.scan_type,
            "target": self.target,
            "status": self.status.value,
            "start_time": self.start_time.isoformat(),
            "end_time": self.end_time.isoformat() if self.end_time else None,
            "vulnerabilities": [vuln.to_dict() for vuln in self.vulnerabilities],
            "scan_config": self.scan_config,
            "error_message": self.error_message,
            "vulnerability_count": len(self.vulnerabilities),
            "severity_breakdown": self._get_severity_breakdown()
        }
    
    def _get_severity_breakdown(self) -> Dict[str, int]:
        """Get breakdown of vulnerabilities by severity."""
        breakdown = {severity.name: 0 for severity in SeverityLevel}
        
        for vuln in self.vulnerabilities:
            breakdown[vuln.severity.name] += 1
        
        return breakdown


class VulnerabilityScanner:
    """Comprehensive vulnerability scanning system."""
    
    def __init__(self, config: Optional[Dict[str, Any]] = None):
        """Initialize vulnerability scanner."""
        self.config = config or {}
        
        # Scan results storage
        self.scan_results: Dict[str, ScanResult] = {}
        
        # CVE database
        self.cve_database: Dict[str, Dict[str, Any]] = {}
        
        # Dependency databases
        self.dependency_databases = {
            "npm": {},
            "pip": {},
            "maven": {},
            "nuget": {},
            "composer": {},
            "gem": {}
        }
        
        # Scan configurations
        self.scan_configs = {
            "network": {
                "ports": [21, 22, 23, 25, 53, 80, 110, 143, 443, 993, 995, 3389, 5432, 3306],
                "timeout": 5,
                "max_threads": 50
            },
            "web": {
                "user_agents": ["NetLink-Scanner/1.0"],
                "timeout": 10,
                "max_redirects": 5
            },
            "dependency": {
                "check_outdated": True,
                "check_vulnerabilities": True,
                "include_dev_dependencies": False
            }
        }
        
        # Statistics
        self.stats = {
            "total_scans": 0,
            "completed_scans": 0,
            "failed_scans": 0,
            "vulnerabilities_found": 0,
            "critical_vulnerabilities": 0,
            "high_vulnerabilities": 0
        }
        
        logger.info("Vulnerability Scanner initialized")
    
    async def scan_network(self, target: str, ports: Optional[List[int]] = None) -> str:
        """Perform network vulnerability scan."""
        scan_id = f"network_{int(time.time())}_{hashlib.md5(target.encode()).hexdigest()[:8]}"
        
        scan_result = ScanResult(
            scan_id=scan_id,
            scan_type="network",
            target=target,
            status=ScanStatus.PENDING,
            start_time=datetime.now(timezone.utc),
            scan_config={"ports": ports or self.scan_configs["network"]["ports"]}
        )
        
        self.scan_results[scan_id] = scan_result
        self.stats["total_scans"] += 1
        
        # Start scan in background
        asyncio.create_task(self._perform_network_scan(scan_result))
        
        return scan_id
    
    async def _perform_network_scan(self, scan_result: ScanResult):
        """Perform actual network scan."""
        try:
            scan_result.status = ScanStatus.RUNNING
            target = scan_result.target
            ports = scan_result.scan_config["ports"]
            
            logger.info(f"Starting network scan of {target}")
            
            # Port scanning
            open_ports = await self._scan_ports(target, ports)
            
            # Service detection and vulnerability checks
            for port in open_ports:
                vulnerabilities = await self._check_port_vulnerabilities(target, port)
                scan_result.vulnerabilities.extend(vulnerabilities)
            
            # SSL/TLS checks for HTTPS ports
            if 443 in open_ports or 8443 in open_ports:
                ssl_vulns = await self._check_ssl_vulnerabilities(target)
                scan_result.vulnerabilities.extend(ssl_vulns)
            
            scan_result.status = ScanStatus.COMPLETED
            scan_result.end_time = datetime.now(timezone.utc)
            self.stats["completed_scans"] += 1
            self.stats["vulnerabilities_found"] += len(scan_result.vulnerabilities)
            
            logger.info(f"Network scan completed: {scan_result.scan_id} - {len(scan_result.vulnerabilities)} vulnerabilities found")
            
        except Exception as e:
            scan_result.status = ScanStatus.FAILED
            scan_result.error_message = str(e)
            scan_result.end_time = datetime.now(timezone.utc)
            self.stats["failed_scans"] += 1
            logger.error(f"Network scan failed: {e}")
    
    async def _scan_ports(self, target: str, ports: List[int]) -> List[int]:
        """Scan ports on target."""
        open_ports = []
        timeout = self.scan_configs["network"]["timeout"]
        
        async def check_port(port):
            try:
                reader, writer = await asyncio.wait_for(
                    asyncio.open_connection(target, port),
                    timeout=timeout
                )
                writer.close()
                await writer.wait_closed()
                return port
            except:
                return None
        
        # Scan ports concurrently
        tasks = [check_port(port) for port in ports]
        results = await asyncio.gather(*tasks, return_exceptions=True)
        
        open_ports = [port for port in results if port is not None and not isinstance(port, Exception)]
        
        return open_ports
    
    async def _check_port_vulnerabilities(self, target: str, port: int) -> List[Vulnerability]:
        """Check vulnerabilities for specific port/service."""
        vulnerabilities = []
        
        # Common vulnerable services
        vulnerable_services = {
            21: {"service": "FTP", "vulns": ["Anonymous FTP access", "Weak encryption"]},
            22: {"service": "SSH", "vulns": ["Weak SSH configuration", "Default credentials"]},
            23: {"service": "Telnet", "vulns": ["Unencrypted communication", "Weak authentication"]},
            25: {"service": "SMTP", "vulns": ["Open relay", "Weak authentication"]},
            80: {"service": "HTTP", "vulns": ["Unencrypted web traffic", "Information disclosure"]},
            110: {"service": "POP3", "vulns": ["Unencrypted email access", "Weak authentication"]},
            143: {"service": "IMAP", "vulns": ["Unencrypted email access", "Weak authentication"]},
            3389: {"service": "RDP", "vulns": ["BlueKeep vulnerability", "Weak RDP configuration"]}
        }
        
        if port in vulnerable_services:
            service_info = vulnerable_services[port]
            
            for vuln_desc in service_info["vulns"]:
                vulnerability = Vulnerability(
                    vuln_id=f"PORT_{port}_{hashlib.md5(vuln_desc.encode()).hexdigest()[:8]}",
                    cve_id=None,
                    title=f"{service_info['service']} Vulnerability",
                    description=vuln_desc,
                    severity=SeverityLevel.MEDIUM,
                    cvss_score=5.0,
                    vulnerability_type=VulnerabilityType.NETWORK,
                    affected_component=f"{service_info['service']} on port {port}",
                    affected_version=None,
                    fixed_version=None,
                    discovery_date=datetime.now(timezone.utc)
                )
                vulnerabilities.append(vulnerability)
        
        return vulnerabilities
    
    async def _check_ssl_vulnerabilities(self, target: str) -> List[Vulnerability]:
        """Check SSL/TLS vulnerabilities."""
        vulnerabilities = []
        
        try:
            import ssl
            import socket
            
            context = ssl.create_default_context()
            context.check_hostname = False
            context.verify_mode = ssl.CERT_NONE
            
            with socket.create_connection((target, 443), timeout=10) as sock:
                with context.wrap_socket(sock, server_hostname=target) as ssock:
                    cert = ssock.getpeercert()
                    cipher = ssock.cipher()
                    version = ssock.version()
                    
                    # Check for weak SSL/TLS versions
                    if version in ['SSLv2', 'SSLv3', 'TLSv1', 'TLSv1.1']:
                        vulnerability = Vulnerability(
                            vuln_id=f"SSL_WEAK_VERSION_{hashlib.md5(version.encode()).hexdigest()[:8]}",
                            cve_id=None,
                            title="Weak SSL/TLS Version",
                            description=f"Server supports weak SSL/TLS version: {version}",
                            severity=SeverityLevel.HIGH,
                            cvss_score=7.5,
                            vulnerability_type=VulnerabilityType.CRYPTOGRAPHIC,
                            affected_component="SSL/TLS Configuration",
                            affected_version=version,
                            fixed_version="TLSv1.2 or higher",
                            discovery_date=datetime.now(timezone.utc)
                        )
                        vulnerabilities.append(vulnerability)
                    
                    # Check for weak ciphers
                    if cipher and 'RC4' in cipher[0] or 'DES' in cipher[0]:
                        vulnerability = Vulnerability(
                            vuln_id=f"SSL_WEAK_CIPHER_{hashlib.md5(cipher[0].encode()).hexdigest()[:8]}",
                            cve_id=None,
                            title="Weak SSL/TLS Cipher",
                            description=f"Server uses weak cipher: {cipher[0]}",
                            severity=SeverityLevel.MEDIUM,
                            cvss_score=5.3,
                            vulnerability_type=VulnerabilityType.CRYPTOGRAPHIC,
                            affected_component="SSL/TLS Configuration",
                            affected_version=cipher[0],
                            fixed_version="Strong cipher suites",
                            discovery_date=datetime.now(timezone.utc)
                        )
                        vulnerabilities.append(vulnerability)
        
        except Exception as e:
            logger.debug(f"SSL check failed for {target}: {e}")
        
        return vulnerabilities
    
    async def scan_web_application(self, target_url: str) -> str:
        """Perform web application vulnerability scan."""
        scan_id = f"web_{int(time.time())}_{hashlib.md5(target_url.encode()).hexdigest()[:8]}"
        
        scan_result = ScanResult(
            scan_id=scan_id,
            scan_type="web_application",
            target=target_url,
            status=ScanStatus.PENDING,
            start_time=datetime.now(timezone.utc),
            scan_config=self.scan_configs["web"]
        )
        
        self.scan_results[scan_id] = scan_result
        self.stats["total_scans"] += 1
        
        # Start scan in background
        asyncio.create_task(self._perform_web_scan(scan_result))
        
        return scan_id
    
    async def _perform_web_scan(self, scan_result: ScanResult):
        """Perform actual web application scan."""
        try:
            scan_result.status = ScanStatus.RUNNING
            target_url = scan_result.target
            
            logger.info(f"Starting web application scan of {target_url}")
            
            async with aiohttp.ClientSession() as session:
                # Basic information gathering
                vulnerabilities = []
                
                # Check for common vulnerabilities
                vulnerabilities.extend(await self._check_http_headers(session, target_url))
                vulnerabilities.extend(await self._check_directory_traversal(session, target_url))
                vulnerabilities.extend(await self._check_xss_vulnerabilities(session, target_url))
                vulnerabilities.extend(await self._check_sql_injection(session, target_url))
                
                scan_result.vulnerabilities = vulnerabilities
            
            scan_result.status = ScanStatus.COMPLETED
            scan_result.end_time = datetime.now(timezone.utc)
            self.stats["completed_scans"] += 1
            self.stats["vulnerabilities_found"] += len(scan_result.vulnerabilities)
            
            logger.info(f"Web application scan completed: {scan_result.scan_id} - {len(scan_result.vulnerabilities)} vulnerabilities found")
            
        except Exception as e:
            scan_result.status = ScanStatus.FAILED
            scan_result.error_message = str(e)
            scan_result.end_time = datetime.now(timezone.utc)
            self.stats["failed_scans"] += 1
            logger.error(f"Web application scan failed: {e}")
    
    async def _check_http_headers(self, session: aiohttp.ClientSession, url: str) -> List[Vulnerability]:
        """Check for missing security headers."""
        vulnerabilities = []
        
        try:
            async with session.get(url) as response:
                headers = response.headers
                
                # Check for missing security headers
                security_headers = {
                    'X-Content-Type-Options': 'Missing X-Content-Type-Options header',
                    'X-Frame-Options': 'Missing X-Frame-Options header',
                    'X-XSS-Protection': 'Missing X-XSS-Protection header',
                    'Strict-Transport-Security': 'Missing HSTS header',
                    'Content-Security-Policy': 'Missing Content Security Policy header'
                }
                
                for header, description in security_headers.items():
                    if header not in headers:
                        vulnerability = Vulnerability(
                            vuln_id=f"HEADER_{header}_{hashlib.md5(url.encode()).hexdigest()[:8]}",
                            cve_id=None,
                            title=f"Missing Security Header: {header}",
                            description=description,
                            severity=SeverityLevel.LOW,
                            cvss_score=3.1,
                            vulnerability_type=VulnerabilityType.WEB_APPLICATION,
                            affected_component="HTTP Headers",
                            affected_version=None,
                            fixed_version=None,
                            discovery_date=datetime.now(timezone.utc)
                        )
                        vulnerabilities.append(vulnerability)
        
        except Exception as e:
            logger.debug(f"Header check failed for {url}: {e}")
        
        return vulnerabilities
    
    async def _check_directory_traversal(self, session: aiohttp.ClientSession, url: str) -> List[Vulnerability]:
        """Check for directory traversal vulnerabilities."""
        vulnerabilities = []
        
        # Directory traversal payloads
        payloads = [
            "../../../etc/passwd",
            "..\\..\\..\\windows\\system32\\drivers\\etc\\hosts",
            "%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd"
        ]
        
        for payload in payloads:
            try:
                test_url = f"{url}?file={payload}"
                async with session.get(test_url) as response:
                    content = await response.text()
                    
                    # Check for signs of successful directory traversal
                    if ("root:" in content and "/bin/" in content) or "127.0.0.1" in content:
                        vulnerability = Vulnerability(
                            vuln_id=f"DIR_TRAVERSAL_{hashlib.md5(payload.encode()).hexdigest()[:8]}",
                            cve_id=None,
                            title="Directory Traversal Vulnerability",
                            description=f"Directory traversal possible with payload: {payload}",
                            severity=SeverityLevel.HIGH,
                            cvss_score=7.5,
                            vulnerability_type=VulnerabilityType.WEB_APPLICATION,
                            affected_component="File Parameter",
                            affected_version=None,
                            fixed_version=None,
                            discovery_date=datetime.now(timezone.utc)
                        )
                        vulnerabilities.append(vulnerability)
                        break  # Found one, no need to test others
            
            except Exception as e:
                logger.debug(f"Directory traversal check failed: {e}")
        
        return vulnerabilities
    
    async def _check_xss_vulnerabilities(self, session: aiohttp.ClientSession, url: str) -> List[Vulnerability]:
        """Check for XSS vulnerabilities."""
        vulnerabilities = []
        
        # XSS payloads
        payloads = [
            "<script>alert('XSS')</script>",
            "javascript:alert('XSS')",
            "<img src=x onerror=alert('XSS')>"
        ]
        
        for payload in payloads:
            try:
                # Test in URL parameter
                test_url = f"{url}?q={payload}"
                async with session.get(test_url) as response:
                    content = await response.text()
                    
                    # Check if payload is reflected without encoding
                    if payload in content:
                        vulnerability = Vulnerability(
                            vuln_id=f"XSS_{hashlib.md5(payload.encode()).hexdigest()[:8]}",
                            cve_id=None,
                            title="Cross-Site Scripting (XSS) Vulnerability",
                            description=f"XSS vulnerability found with payload: {payload}",
                            severity=SeverityLevel.MEDIUM,
                            cvss_score=6.1,
                            vulnerability_type=VulnerabilityType.WEB_APPLICATION,
                            affected_component="URL Parameter",
                            affected_version=None,
                            fixed_version=None,
                            discovery_date=datetime.now(timezone.utc)
                        )
                        vulnerabilities.append(vulnerability)
            
            except Exception as e:
                logger.debug(f"XSS check failed: {e}")
        
        return vulnerabilities
    
    async def _check_sql_injection(self, session: aiohttp.ClientSession, url: str) -> List[Vulnerability]:
        """Check for SQL injection vulnerabilities."""
        vulnerabilities = []
        
        # SQL injection payloads
        payloads = [
            "' OR '1'='1",
            "1' UNION SELECT NULL--",
            "'; DROP TABLE users--"
        ]
        
        for payload in payloads:
            try:
                test_url = f"{url}?id={payload}"
                async with session.get(test_url) as response:
                    content = await response.text()
                    
                    # Check for SQL error messages
                    sql_errors = [
                        "SQL syntax error",
                        "mysql_fetch_array",
                        "ORA-01756",
                        "Microsoft OLE DB Provider",
                        "PostgreSQL query failed"
                    ]
                    
                    for error in sql_errors:
                        if error.lower() in content.lower():
                            vulnerability = Vulnerability(
                                vuln_id=f"SQLI_{hashlib.md5(payload.encode()).hexdigest()[:8]}",
                                cve_id=None,
                                title="SQL Injection Vulnerability",
                                description=f"SQL injection vulnerability found with payload: {payload}",
                                severity=SeverityLevel.HIGH,
                                cvss_score=8.8,
                                vulnerability_type=VulnerabilityType.WEB_APPLICATION,
                                affected_component="Database Query",
                                affected_version=None,
                                fixed_version=None,
                                discovery_date=datetime.now(timezone.utc)
                            )
                            vulnerabilities.append(vulnerability)
                            break
            
            except Exception as e:
                logger.debug(f"SQL injection check failed: {e}")

        return vulnerabilities

    async def scan_dependencies(self, project_path: str, package_manager: str = "auto") -> str:
        """Scan project dependencies for vulnerabilities."""
        scan_id = f"deps_{int(time.time())}_{hashlib.md5(project_path.encode()).hexdigest()[:8]}"

        scan_result = ScanResult(
            scan_id=scan_id,
            scan_type="dependency",
            target=project_path,
            status=ScanStatus.PENDING,
            start_time=datetime.now(timezone.utc),
            scan_config={"package_manager": package_manager}
        )

        self.scan_results[scan_id] = scan_result
        self.stats["total_scans"] += 1

        # Start scan in background
        asyncio.create_task(self._perform_dependency_scan(scan_result))

        return scan_id

    async def _perform_dependency_scan(self, scan_result: ScanResult):
        """Perform dependency vulnerability scan."""
        try:
            scan_result.status = ScanStatus.RUNNING
            project_path = Path(scan_result.target)
            package_manager = scan_result.scan_config["package_manager"]

            logger.info(f"Starting dependency scan of {project_path}")

            # Auto-detect package manager if needed
            if package_manager == "auto":
                package_manager = self._detect_package_manager(project_path)

            vulnerabilities = []

            if package_manager == "npm":
                vulnerabilities = await self._scan_npm_dependencies(project_path)
            elif package_manager == "pip":
                vulnerabilities = await self._scan_pip_dependencies(project_path)
            elif package_manager == "maven":
                vulnerabilities = await self._scan_maven_dependencies(project_path)
            else:
                logger.warning(f"Unsupported package manager: {package_manager}")

            scan_result.vulnerabilities = vulnerabilities
            scan_result.status = ScanStatus.COMPLETED
            scan_result.end_time = datetime.now(timezone.utc)
            self.stats["completed_scans"] += 1
            self.stats["vulnerabilities_found"] += len(vulnerabilities)

            logger.info(f"Dependency scan completed: {scan_result.scan_id} - {len(vulnerabilities)} vulnerabilities found")

        except Exception as e:
            scan_result.status = ScanStatus.FAILED
            scan_result.error_message = str(e)
            scan_result.end_time = datetime.now(timezone.utc)
            self.stats["failed_scans"] += 1
            logger.error(f"Dependency scan failed: {e}")

    def _detect_package_manager(self, project_path: Path) -> str:
        """Auto-detect package manager from project files."""
        if (project_path / "package.json").exists():
            return "npm"
        elif (project_path / "requirements.txt").exists() or (project_path / "Pipfile").exists():
            return "pip"
        elif (project_path / "pom.xml").exists():
            return "maven"
        elif (project_path / "composer.json").exists():
            return "composer"
        elif (project_path / "Gemfile").exists():
            return "gem"
        else:
            return "unknown"

    async def _scan_npm_dependencies(self, project_path: Path) -> List[Vulnerability]:
        """Scan NPM dependencies for vulnerabilities."""
        vulnerabilities = []

        try:
            # Run npm audit
            result = subprocess.run(
                ["npm", "audit", "--json"],
                cwd=project_path,
                capture_output=True,
                text=True,
                timeout=60
            )

            if result.returncode == 0 or result.stdout:
                audit_data = json.loads(result.stdout)

                if "vulnerabilities" in audit_data:
                    for vuln_id, vuln_data in audit_data["vulnerabilities"].items():
                        vulnerability = Vulnerability(
                            vuln_id=f"NPM_{vuln_id}",
                            cve_id=vuln_data.get("cve", [None])[0] if vuln_data.get("cve") else None,
                            title=vuln_data.get("title", "NPM Vulnerability"),
                            description=vuln_data.get("overview", ""),
                            severity=self._map_npm_severity(vuln_data.get("severity", "low")),
                            cvss_score=float(vuln_data.get("cvss", {}).get("score", 0)),
                            vulnerability_type=VulnerabilityType.DEPENDENCY,
                            affected_component=vuln_data.get("module_name", "Unknown"),
                            affected_version=vuln_data.get("vulnerable_versions", ""),
                            fixed_version=vuln_data.get("patched_versions", ""),
                            discovery_date=datetime.now(timezone.utc),
                            references=vuln_data.get("references", [])
                        )
                        vulnerabilities.append(vulnerability)

        except Exception as e:
            logger.error(f"NPM audit failed: {e}")

        return vulnerabilities

    async def _scan_pip_dependencies(self, project_path: Path) -> List[Vulnerability]:
        """Scan Python dependencies for vulnerabilities."""
        vulnerabilities = []

        try:
            # Use safety to check for known vulnerabilities
            result = subprocess.run(
                ["safety", "check", "--json"],
                cwd=project_path,
                capture_output=True,
                text=True,
                timeout=60
            )

            if result.stdout:
                safety_data = json.loads(result.stdout)

                for vuln_data in safety_data:
                    vulnerability = Vulnerability(
                        vuln_id=f"PIP_{vuln_data.get('id', 'unknown')}",
                        cve_id=None,
                        title=f"Python Package Vulnerability: {vuln_data.get('package', 'Unknown')}",
                        description=vuln_data.get("advisory", ""),
                        severity=SeverityLevel.MEDIUM,  # Safety doesn't provide CVSS scores
                        cvss_score=5.0,
                        vulnerability_type=VulnerabilityType.DEPENDENCY,
                        affected_component=vuln_data.get("package", "Unknown"),
                        affected_version=vuln_data.get("installed_version", ""),
                        fixed_version=vuln_data.get("vulnerable_spec", ""),
                        discovery_date=datetime.now(timezone.utc)
                    )
                    vulnerabilities.append(vulnerability)

        except Exception as e:
            logger.error(f"Python safety check failed: {e}")

        return vulnerabilities

    async def _scan_maven_dependencies(self, project_path: Path) -> List[Vulnerability]:
        """Scan Maven dependencies for vulnerabilities."""
        vulnerabilities = []

        try:
            # Use OWASP Dependency Check
            result = subprocess.run(
                ["mvn", "org.owasp:dependency-check-maven:check", "-Dformat=JSON"],
                cwd=project_path,
                capture_output=True,
                text=True,
                timeout=300
            )

            # Parse dependency-check report
            report_path = project_path / "target" / "dependency-check-report.json"
            if report_path.exists():
                async with aiofiles.open(report_path, 'r') as f:
                    report_data = json.loads(await f.read())

                for dependency in report_data.get("dependencies", []):
                    for vuln in dependency.get("vulnerabilities", []):
                        vulnerability = Vulnerability(
                            vuln_id=f"MAVEN_{vuln.get('name', 'unknown')}",
                            cve_id=vuln.get("name") if vuln.get("name", "").startswith("CVE-") else None,
                            title=vuln.get("description", "Maven Dependency Vulnerability"),
                            description=vuln.get("description", ""),
                            severity=self._map_cvss_severity(vuln.get("cvssv3", {}).get("baseScore", 0)),
                            cvss_score=float(vuln.get("cvssv3", {}).get("baseScore", 0)),
                            vulnerability_type=VulnerabilityType.DEPENDENCY,
                            affected_component=dependency.get("fileName", "Unknown"),
                            affected_version=None,
                            fixed_version=None,
                            discovery_date=datetime.now(timezone.utc),
                            references=[ref.get("url") for ref in vuln.get("references", [])]
                        )
                        vulnerabilities.append(vulnerability)

        except Exception as e:
            logger.error(f"Maven dependency check failed: {e}")

        return vulnerabilities

    def _map_npm_severity(self, npm_severity: str) -> SeverityLevel:
        """Map NPM severity to CVSS severity."""
        mapping = {
            "info": SeverityLevel.NONE,
            "low": SeverityLevel.LOW,
            "moderate": SeverityLevel.MEDIUM,
            "high": SeverityLevel.HIGH,
            "critical": SeverityLevel.CRITICAL
        }
        return mapping.get(npm_severity.lower(), SeverityLevel.LOW)

    def _map_cvss_severity(self, cvss_score: float) -> SeverityLevel:
        """Map CVSS score to severity level."""
        if cvss_score == 0.0:
            return SeverityLevel.NONE
        elif cvss_score <= 3.9:
            return SeverityLevel.LOW
        elif cvss_score <= 6.9:
            return SeverityLevel.MEDIUM
        elif cvss_score <= 8.9:
            return SeverityLevel.HIGH
        else:
            return SeverityLevel.CRITICAL

    def get_scan_result(self, scan_id: str) -> Optional[Dict[str, Any]]:
        """Get scan result by ID."""
        scan_result = self.scan_results.get(scan_id)
        return scan_result.to_dict() if scan_result else None

    def get_all_scan_results(self, limit: int = 100) -> List[Dict[str, Any]]:
        """Get all scan results."""
        results = list(self.scan_results.values())
        results.sort(key=lambda r: r.start_time, reverse=True)
        return [result.to_dict() for result in results[:limit]]

    def get_vulnerabilities(self, severity: Optional[SeverityLevel] = None, vuln_type: Optional[VulnerabilityType] = None) -> List[Dict[str, Any]]:
        """Get vulnerabilities with optional filters."""
        all_vulnerabilities = []

        for scan_result in self.scan_results.values():
            all_vulnerabilities.extend(scan_result.vulnerabilities)

        # Apply filters
        if severity:
            all_vulnerabilities = [v for v in all_vulnerabilities if v.severity == severity]

        if vuln_type:
            all_vulnerabilities = [v for v in all_vulnerabilities if v.vulnerability_type == vuln_type]

        # Sort by severity and discovery date
        all_vulnerabilities.sort(key=lambda v: (v.severity.value, v.discovery_date), reverse=True)

        return [vuln.to_dict() for vuln in all_vulnerabilities]

    def get_statistics(self) -> Dict[str, Any]:
        """Get vulnerability scanner statistics."""
        # Count vulnerabilities by severity
        severity_counts = {severity.name: 0 for severity in SeverityLevel}
        type_counts = {vuln_type.value: 0 for vuln_type in VulnerabilityType}

        for scan_result in self.scan_results.values():
            for vuln in scan_result.vulnerabilities:
                severity_counts[vuln.severity.name] += 1
                type_counts[vuln.vulnerability_type.value] += 1

        return {
            **self.stats,
            "active_scans": len([s for s in self.scan_results.values() if s.status == ScanStatus.RUNNING]),
            "total_scan_results": len(self.scan_results),
            "severity_distribution": severity_counts,
            "vulnerability_type_distribution": type_counts
        }

    def cancel_scan(self, scan_id: str) -> bool:
        """Cancel a running scan."""
        if scan_id in self.scan_results:
            scan_result = self.scan_results[scan_id]
            if scan_result.status == ScanStatus.RUNNING:
                scan_result.status = ScanStatus.CANCELLED
                scan_result.end_time = datetime.now(timezone.utc)
                logger.info(f"Scan cancelled: {scan_id}")
                return True
        return False

    def cleanup_old_results(self, max_age_hours: int = 168):  # 7 days default
        """Clean up old scan results."""
        cutoff_time = datetime.now(timezone.utc) - timedelta(hours=max_age_hours)

        old_scan_ids = [
            scan_id for scan_id, scan_result in self.scan_results.items()
            if scan_result.start_time < cutoff_time
        ]

        for scan_id in old_scan_ids:
            del self.scan_results[scan_id]

        if old_scan_ids:
            logger.info(f"Cleaned up {len(old_scan_ids)} old scan results")

        return len(old_scan_ids)

    async def update_cve_database(self):
        """Update CVE database from external sources."""
        try:
            # Download CVE data from NIST NVD
            url = "https://services.nvd.nist.gov/rest/json/cves/2.0"

            async with aiohttp.ClientSession() as session:
                async with session.get(url) as response:
                    if response.status == 200:
                        cve_data = await response.json()

                        # Process CVE data
                        for cve in cve_data.get("vulnerabilities", []):
                            cve_id = cve.get("cve", {}).get("id")
                            if cve_id:
                                self.cve_database[cve_id] = cve

                        logger.info(f"Updated CVE database with {len(cve_data.get('vulnerabilities', []))} entries")
                        return True

        except Exception as e:
            logger.error(f"Failed to update CVE database: {e}")

        return False

    def export_results(self, scan_ids: Optional[List[str]] = None) -> Dict[str, Any]:
        """Export scan results."""
        if scan_ids:
            results = {sid: self.scan_results[sid].to_dict() for sid in scan_ids if sid in self.scan_results}
        else:
            results = {sid: result.to_dict() for sid, result in self.scan_results.items()}

        return {
            "export_timestamp": datetime.now(timezone.utc).isoformat(),
            "scan_results": results,
            "statistics": self.get_statistics()
        }


# Global instance
vulnerability_scanner = VulnerabilityScanner()
